### 1A. Use primitives and wrapper classes, including, operators, parentheses, type promotion and casting

#### üìå Java Primitives
|Type| Description | Min Value | Max Value | 
|:---:|:-----------:|:---------:|:----------:|
|byte | 8-bit SIGNED 2's complement | -2<sup>7</sup>| 2<sup>7</sup> - 1|
|short|16-bit SIGNED 2's complement | -2<sup>15</sup>|2<sup>15</sup> - 1|
|int| 32-bit SIGNED 2's complement | signed: -2<sup>31</sup><br/>unsigned: 0 |signed:  2<sup>31</sup> - 1<br /> unsigned: 2<sup>32</sup> - 1|
|long|64-bit 2's complement| signed: -2<sup>63</sup> <br /> unsigned: 0| signed: 2<sup>63</sup> - 1 <br/> unsigned: 2<sup>64</sup> - 1|
|float|32-bit IEEE 754 floating point|---| --- |
|double|64-bit IEEE 754 floating point|---|---|
|boolean| `true` or `false` | N/A | N/A |
| char |single 16-bit Unicode character| '\u0000' (0)| `\uffff` (65535)| 

‚≠ê In addition to the eight types above, Java also provides special support for `java.lang.String`. String objects are immutable. It is technically not a primitive.

‚ö†Ô∏è **WARNING**: Do not use float and double for precise values, such as currency. Use `java.math.BigDecimal` class instead.


#### üìå Java `default` values
Primitives, if uninitialized gets default values. Final and local variables should always be initialized too. The following table lists the default values in Java.
| Type | Default Value |
|:-----:| :------------|
| byte | 0 |
| char | '\u0000' |
| short | 0 |
| int | 0 |
| long | 0L |
| float | 0f |
| double | 0d |
| Object | null |
|boolean | false |

#### üìå Java Literals
1. A **literal** is a source code representation of a fixed value. They can be represented without requiring computation. 
2. An integer literal is of type `Long` if it ends withe letter `L`, e.g. `1L`.
3. The prefix `0x` indicates hexadecimal.
4. The prefix `0b` indicates binary
5. A floating point literal is of type `float` if it ends with `f` or `F`. Otherwise, it defaults to a `double`.
6. There is also a special kind of literal called a `class` literal, e.g. `String.class`. It refers to the class object of the object/primitive. 

```java
int decimalValue = 26;
int hexaValue = 0x1A;
int binaryValue = 0b11010;

double d1 = 123.4;
// same value as d1, but in scientific notation
double d2 = 1.234e2;
float f1  = 123.4f;
```

#### üìå Underscore Characters in Numeric Literals
In Java 7 and later versions, an underscore can be places in between digits of a numerical literal. This improves readability of code.
```java
long creditCardNumber = 1234_5678_9012_3456L;
long socialSecurityNumber = 999_99_9999L;
float pi =  3.14_15F;
long hexBytes = 0xFF_EC_DE_5E;
long hexWords = 0xCAFE_BABE;
long maxLong = 0x7fff_ffff_ffff_ffffL;
byte nybbles = 0b0010_0101;
long bytes = 0b11010010_01101001_10010100_10010010;
```

There are limitations as to where an underscore can be placed. <br/>
 ‚ùå Beginning or end of a number `int a = _1000_`. <br/>
 ‚ùå Adjacent to a decimal point in a floating point literal `float f = 1._009` <br/>
 ‚ùå Prior to an `F` or `L` suffix `long l = 100_L` <br/>
 ‚ùå Positions where a string of decimals is expected `int x4 = 0_x52`; <br/>

#### üìå Java Wrapper Classes
Wrapper classes are object representations of primitive data types. They are used to represent primitives when an `Object` is required. Placing primitive types into wrapper classes is called **BOXING**. The reverse, i.e. from wrapper object to primitive is called **UNBOXING**

Performance-wise, primitives are faster than their boxed counterparts. 

The table below shows the primitive types with their `Wrapper` classes.

|Primitive Type | Wrapper Class | Constructor Arguments|
| ------------- |:-------------:| :-----:|
|`byte` | `Byte` | byte or String |
|`short` | `Short` | short or String |
|`int` | `Integer` | int or String |
|`long` | `Long` | long or String |
|`float` | `Float` | float, double or String |
|`double` | `Double` | double or String |
|`char` | `Character` | char |
|`boolean` | `Boolean` | boolean or String |

#### üìå Java Boxing/Unboxing

```java
    // Boxing
    Integer i  = new Integer(8);
    
    //Unboxing
    int i2 = i.intValue();
```
**Boxing** . Primitive values, like `int`, `boolean` are converted to associated wrapper `Object`. 

**Unboxing**. Wrapper objects are converted to primitive values, i.e. `int`, `boolean` 

#### üìåJava Autoboxing
Java 5 introduced autoboxing. Autoboxing/unboxing means automatic conversion of primitives to objects or vice versa, when needed. 
It can happen during _assignments_, _passing parameters to methods_, _returning values from methods_, _variable comparisons_, _arithmetic operations_, and _others_.  
For example,
```java
   /*
   * 10 is a primitive int. It is autoboxed and saved to i of type Integer Object
   */
   Integer i = 10;
   
   // Auto unboxing happens here
   int j = i;
```

#### üìå Object Interning
Object interning is keeping only one copy of every distinct Java object. The object must be immutable. These objects are stored in an **_INTERN POOL_** . In Java, when primitive values are boxed into a wrapper object, the values are interned, and any boxing conversions  of these values are guaranteed to result in the same object. 

There are consequences when comparing wrapper objects using `==` or `.equals`. Remember that `==` operator compares the reference of two objects while `equals` compares values. Thus, from the example below both equality checks would return to true.
```java
Integer a = 5; //automatically boxed and interned
Integer b = 5; // automatically boxed and is already interned

System.out.println(a == b); //true
System.out.println(a.equals(b)); //true
```

#### üìå Java `null` type
Null values represents a null reference, meaning the memory address does not refer to any object. It is the default value of Java reference variables. Primitives cannot be assigned a null.

#### üìå Array Manipulation
Java SE provides methods to perform some of the most common manipulations related to arrays, such as sorting, copying and searching in `Java.util.Arrays` class. 

‚ÑπÔ∏è Additional Notes :
1. Primitive data types cannot be placed in Java Collections. The primitive values should be boxed first before putting them in a collection.
2. Java **DOES NOT** support operator overloading. When arithmetic operations are performed on wrapper objects, automatic boxing/unboxing is done by the compiler. _[i should think about this ü§î]_


### [REFERENCES]
1. [zetcode](https://zetcode.com/lang/java/datatypes2/)
2. [Java Nuts and Bolts](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)
